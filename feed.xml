<feed xmlns="http://www.w3.org/2005/Atom"> <id>/</id><title>Gaoy's Blog</title><subtitle>A minimal, responsive, and powerful Jekyll theme for presenting professional writing.</subtitle> <updated>2023-05-04T13:48:52+00:00</updated> <author> <name>gaoy</name> <uri>/</uri> </author><link rel="self" type="application/atom+xml" href="/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="/"/> <generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator> <rights> © 2023 gaoy </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Spring三级缓存决循环依赖</title><link href="/posts/2023033001/" rel="alternate" type="text/html" title="Spring三级缓存决循环依赖" /><published>2023-03-30T10:12:00+00:00</published> <updated>2023-03-30T11:54:55+00:00</updated> <id>/posts/2023033001/</id> <content src="/posts/2023033001/" /> <author> <name>gaoy</name> </author> <summary> 假设A和B的定义如下： public class A { private B b; public A(B b) { this.b = b; } } public class B { private A a; public B(A a) { this.a = a; } } 当Spring容器启动时，它会先创建A实例，但是在创建A实例的过程中发现需要依赖B实例，因此Spring会创建B实例并注入到A实例中，如下所示： 1.创建A实例，发现需要B实例。 2.创建B实例，并将其放入earlySingletonObjects缓存中。 3.在创建B实例的过程中，发现需要A实例。因为A实例已经在第1步中创建了，因此可以直接从singletonObjects缓存中获取A实例，并将其注入到B实例中。 4.将B实例... </summary> </entry> <entry><title>Java文档</title><link href="/posts/2022111901/" rel="alternate" type="text/html" title="Java文档" /><published>2022-11-19T10:12:00+00:00</published> <updated>2023-05-04T13:47:50+00:00</updated> <id>/posts/2022111901/</id> <content src="/posts/2022111901/" /> <author> <name>gaoy</name> </author> <summary> 线程池 线程池7个参数说明： corePoolSize（核心线程数）：线程池中会维护一个最小的线程数量，即使这些线程处理空闲状态，他们也不会被销毁，除非设置了allowCoreThreadTimeOut。这里的最小线程数量即是corePoolSize。任务提交到线程池后，首先会检查当前线程数是否达到了corePoolSize，如果没有达到的话，则会创建一个新线程来处理这个任务。 maximumPoolSize（最大线程数）：当前线程数达到corePoolSize后，如果继续有任务被提交到线程池，会将任务缓存到工作队列中。如果队列也已满，则会去创建一个新线程来出来这个处理。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即由maximunPoolSize指定。 keepAliveTime（空闲线程存活时间... </summary> </entry> <entry><title>ubuntu安装ngrok</title><link href="/posts/2022041901/" rel="alternate" type="text/html" title="ubuntu安装ngrok" /><published>2022-04-19T02:52:00+00:00</published> <updated>2022-04-19T02:52:00+00:00</updated> <id>/posts/2022041901/</id> <content src="/posts/2022041901/" /> <author> <name>gaoy</name> </author> <summary> 安装go apt-get install golang 下载ngrok源码 git clone https://github.com/inconshreveable/ngrok.git 配置环境变量 sudo vim /etc/profile export GOPATH=/usr/local/go export PATH=$PATH:$GOPATH/bin export NGROK_DOMAIN="m9d2.cn" 生成自签名证书 openssl genrsa -out base.key 2048 openssl req -new -x509 -nodes -key base.key -days 10000 -subj "/CN=$NGROK_DOMAIN" -out base.pem openssl genrsa -out server.key 2048 ope... </summary> </entry> <entry><title>mysql8.0开启远程访问权限</title><link href="/posts/2022030802/" rel="alternate" type="text/html" title="mysql8.0开启远程访问权限" /><published>2022-03-08T08:54:00+00:00</published> <updated>2022-03-08T08:54:00+00:00</updated> <id>/posts/2022030802/</id> <content src="/posts/2022030802/" /> <author> <name>gaoy</name> </author> <summary> 1.设置密码 ALTER USER 'root'@'localhost' IDENTIFIED BY '123456'; 2.修改host update user set host='%' where user='root'; 3.刷新权限 flush privileges; </summary> </entry> <entry><title>gem 添加国内源</title><link href="/posts/2022030801/" rel="alternate" type="text/html" title="gem 添加国内源" /><published>2022-03-08T08:53:00+00:00</published> <updated>2022-03-08T08:53:00+00:00</updated> <id>/posts/2022030801/</id> <content src="/posts/2022030801/" /> <author> <name>gaoy</name> </author> <summary> 查看当前使用的源地址 gem sources gem 删除默认源命令 gem sources --remove https://rubygems.org/ gem 添加国内源 gem sources -a https://gems.ruby-china.com/ ### gem sources --add https://mirrors.tuna.tsinghua.edu.cn/rubygems/ 检测方法 gem sources -l 更新源的缓存 gem sources -u </summary> </entry> </feed>
